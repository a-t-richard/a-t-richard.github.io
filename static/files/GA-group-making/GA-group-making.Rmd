---
title: "Group making using genetic algorithm"
date: "2022-10-14"
output:
  html_document:
    preserve_yaml: true
    variant: gfm
---

## Introduction

Making relevant groups of students, for example to do some practical exercises or in
[problem-based learning](https://teaching.cornell.edu/teaching-resources/engaging-students/problem-based-learning), 
is one common problem of teachers.
Groups must not be too small, or too large, and the mean "level" of each group should be as
homogeneous as possible.
We don't want one group with only students in difficulty and one group with only "good-grades" students.
In addition, students in each group should get along with each others, and all participate to solve the
exercice.

Generally, we just let the students make their own groups with a size limitation, or we just do
random groups. Obviously, it's quite sub-optimal.

A possible way should be to use a metric (grades, IQ, et.) to evaluate students and make groups
according to this metric.
To illustrate this post, I decided to use the
["Reading the Mind in the Eyes" Test (RMET)](https://link.springer.com/referenceworkentry/10.1007/978-3-319-28099-8_549-1).
This test aims evaluate the "emotional"/"social" intelligence of the subject.
According to [Riedl *et al.* (2021)](https://www.pnas.org/doi/full/10.1073/pnas.2005737118),
an high social perceptiveness of group members is quite corelated to high collective intelligence.
So, why not using RMET as a base to construct groups of students?

Let's first generate some random RMET scores to represent our students.
In my case, I'm teaching to 18-25 years old students at university.
According to [Kynast *et al.* (2021)](https://www.frontiersin.org/articles/10.3389/fnagi.2020.607107/full),
the mean RMET's score for this age range is 26 (with a standard deviation of 3.2).

```{r students}
nbStudents <- 20
seed <- 42

set.seed(seed)
students <- data.frame(rmets=round(rnorm(nbStudents, mean=26, sd=3.2)))
students
```

Now, what we want to distribute these students into N groups in the
most homogeneous way possible, with a minimum and maximum group size
(defined below).

```{r setupMinMax}
minStudentsByGroup <- 3
maxStudentsByGroup <- 6

nbGroupsMax <- nbStudents %/% minStudentsByGroup
nbGroupsMin <- nbStudents %/% maxStudentsByGroup
```

This problem can be seen as a variation of the
[knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).
However, instead of choosing wich item to put in a unique bag,
we want to take all the items and distribute them as homogeneously
as possible into several bags.
Knapsack problem is a
[NP-hard problem](https://en.wikipedia.org/wiki/NP-hardness).
We can then suppose that our variation of this problem is also
NP-hard.

Testing all the possible solutions is then not a option, and
we have to use a 
[metaheuristic algorithm](https://www.sciencedirect.com/science/article/pii/B9780128133149000104).

(to rewrite)
A genetic algorithm, in our case, could be quite adapted
to explore possible solutions and find the best ones.
It is also the occasion to test, and explain step by step, 
genetic algorithms with a pratical use case.
Beside, [classic knapsack problem](https://towardsdatascience.com/genetic-algorithm-in-r-the-knapsack-problem-3edc5b07d4a7) 
can be solved by using genetic algorithm.

## Naively apply basic genetic algorithm

TODO

### Representing our solutions

TODO

### Defining the score of a solution

* valid group
* a RMET mean score by group the highest possible
* a global RMET standard deviation between groups the
  lowest possible (we don't want one group with a poor RMET mean score
  and one other group with a high RMET mean score)

```{r fitnessFunc}
fitness=function(solution)
{
  # each row correspond to a group, each column to a student
  m <- matrix(solution, ncol=nbStudents, byrow=TRUE)

  # get number of groups by students and students by groups
  nbGroupsByStudent <- colSums(m)
  nbStudentsByGroup <- rowSums(m)
  # remove empty groups
  nbStudentsByGroup <- nbStudentsByGroup[nbStudentsByGroup != 0]
  
  # if solution propose groups not valid, return a score of zero
  if(any(nbGroupsByStudent != 1) 
     || any(nbStudentsByGroup < minStudentsByGroup) 
     || any(nbStudentsByGroup > maxStudentsByGroup))
    return(0)

  # compute mean RMET by group
  total <- 0.0
  means <- c()
  for(i in 1:nbGroupsMax){
    studentsInGroup <- m[i, ]
    rmets <- students[studentsInGroup==1,]
    if(length(rmets) > 0){
      means[length(means)+1] <- mean(rmets)
    }
  }

  # compute score as the "macro" mean of means RMET by group
  score <- mean(means)
  
  # compute penalty as the standard deviation of means RMET by group
  penalty <- sd(means)
  
  # return score - penalties
  return(score - penalty)
}
```

```{r test-fitnessFunc}
library(GA)

GA=ga(
  type='binary',
  fitness=fitness,
  nBits=nbStudents*nbGroupsMax,
  maxiter=1000,
  popSize=100,
  seed=seed,
  keepBest=TRUE,
  monitor = FALSE
)

plot(GA, ylim=c(0, max(students)))
```

### Why it doesn’t work?

```{r nbComb}
library(gtools)
library(collections)


# To keep the combinations found for later
diffGroupSizesCombinations <- dict()
k <- 1 # to count the number of combinations found

# to define the different group size possible
diffGroupSize <- minStudentsByGroup:maxStudentsByGroup
totNbCombinations <- 0 # to count the total number of valid combinations

# for each number of group possible
for(i in nbGroupsMin:nbGroupsMax){
  
  # compute the combinations of i groups
  # from the different possible group sizes
  c <- combinations(
      n=length(diffGroupSize), 
      r=i,
      v = diffGroupSize,
      repeats.allowed = TRUE
    )
  
  # for each combination found
  for(j in 1:nrow(c)){
    cj <- c[j, ] # the combination
    
    # check if the sum of groups’ size
    # correspond to the number of students
    if(sum(cj) == nbStudents){
      print(cj)
      
      # keep the combination for later
      diffGroupSizesCombinations$set(as.character(k), cj)
      k = k + 1
      
      # compute the number of combination of students
      # for configuration of group sizes cj 
      nbCombinations <- 1.0
      nbStudentsLeft <- nbStudents
      # for each group size in cj configuration
      for(groupSize in cj){ 
        # compute combinations of group size
        # from students not grouped yet
        cGroupSize <- combinations(n=nbStudentsLeft, r=groupSize)
        
        # multiply with number of combinations found for previous groups
        nbCombinations = nbCombinations * nrow(cGroupSize)
        
        # update number of student not grouped yet
        nbStudentsLeft = nbStudentsLeft - groupSize
      }
      print(nbCombinations)
      
      # add number of combinations found for cj to the total
      totNbCombinations = totNbCombinations + nbCombinations
    }
  }
}

totNbCombinations
```

## Customizing GA to reduce solutions’ scope to only valid possibilities

TODO

### Initial population

```{r popFunc}
group_population <- function(object){
  # init population with empty matrix
  population <- matrix(
      rep(0, object@nBits*object@popSize),
      ncol=object@nBits,
      nrow=object@popSize
    )
  
  # generate chromosomes of each individual of the population
  for(i in 1:object@popSize){
    # choose one possible combination of group size
    k <- sample(1:diffGroupSizesCombinations$size(), 1)
    groupSizes <- diffGroupSizesCombinations$get(as.character(k))
    
    # for each group
    studentsNotGroupedYet <- 1:nbStudents
    for(j in 1:length(groupSizes)){
      # choose n students from students not grouped yet
      studentIds <- sample(
          studentsNotGroupedYet,
          groupSizes[j]
        )
      
      # for each student selected
      for(id in studentIds){
        # set student to group j
        population[i, nbStudents * (j-1) + id] = 1
        # remove student from students not grouped yet
        studentsNotGroupedYet = studentsNotGroupedYet[studentsNotGroupedYet != id]
      }
    }
  }
  
  return(population)
}
```

```{r test-popFunc}
GA=ga(
    type='binary',
    fitness=fitness,
    nBits=nbStudents*nbGroupsMax,
    population = group_population,
    maxiter=10,
    popSize=100,
    seed=seed,
    keepBest=TRUE,
    monitor = FALSE
  )

plot(GA, ylim=c(0, max(students)))
```

### Cross-over best solutions

```{r crossoverFunc}

group_crossover = function(object, parents){
  parentsFitness <- object@fitness[parents]
  parents <- object@population[parents,,drop = FALSE]
  n <- ncol(parents)
  
  children <- matrix(rep(0, 2*n), nrow = 2, ncol = n)
  childrenFitness <- rep(NA, 2)
  
  for(i in 1:nrow(parents)){
    # Select groups in parent 1
    parent1 <- parents[i,]
    groups <- matrix(parent1, ncol = nbStudents, byrow = TRUE)
    nbStudentsByGroup <- rowSums(groups)
    nbStudentsByGroup <- nbStudentsByGroup[nbStudentsByGroup != 0]
    nbGroupKept <- (length(nbStudentsByGroup) - 1) %/% 2
    groupKeptIds <- sample(1:length(nbStudentsByGroup), nbGroupKept, replace = FALSE)
    groupIdsLeft <- 1:length(nbStudentsByGroup)
    studentIdsLeft <-1:nbStudents
    for(groupKeptId in groupKeptIds){
      groupKept <- groups[groupKeptId,]
      studentIds <- which(groupKept == 1)
      for(studentId in studentIds){
        children[i, nbStudents * (groupKeptId-1) + studentId] = 1
        studentIdsLeft = studentIdsLeft[studentIdsLeft != studentId]
      }
      groupIdsLeft = groupIdsLeft[groupIdsLeft != groupKeptId]
    }
    
    # Select groups in parent 2 to keep their internal structures
    parent2 <- if(i==1) parents[2,] else parents[1,]
    groupsInParent2 <- matrix(parent2, ncol = nbStudents, byrow = TRUE)
    studentsByGroupsInParent2 <- rowSums(groupsInParent2)
    nbGroupsInParent2 <- length(studentsByGroupsInParent2[studentsByGroupsInParent2 != 0])
    
    while(length(groupIdsLeft) > 1){
      groupId <- sample(groupIdsLeft, 1)
      groupSize <- nbStudentsByGroup[groupId]
      while(groupSize > 0){
        groupIdInParent2 <- sample(1:nbGroupsInParent2, 1)
        studentIds <- which(groupsInParent2[groupIdInParent2, ] == 1)
        studentSelectedIds <- intersect(studentIds, studentIdsLeft)
        if(length(studentSelectedIds) > groupSize)
          studentSelectedIds <- sample(studentSelectedIds, groupSize, replace = FALSE)
        
        for(studentId in studentSelectedIds){
          children[i, nbStudents * (groupId-1) + studentId] = 1
          studentIdsLeft = studentIdsLeft[studentIdsLeft != studentId]
        }
        groupSize = groupSize - length(studentSelectedIds)
      }
      groupIdsLeft = groupIdsLeft[groupIdsLeft != groupId]
    }
    
    # Fill last group left with students left
    for(studentId in studentIdsLeft){
      groupId <- groupIdsLeft[1]
      children[i, nbStudents * (groupId-1) + studentId] = 1
    }
  }
  
  return(list(children=children, fitness=childrenFitness))
}

```

```{r test-coFunc}
GA=ga(
    type='binary',
    fitness=fitness,
    nBits=nbStudents*nbGroupsMax,
    population = group_population,
    crossover = group_crossover,
    maxiter=10,
    popSize=100,
    seed=seed,
    keepBest=TRUE,
    monitor=FALSE
  )

plot(GA, ylim=c(0, max(students)))
```

### Mutate solutions

```{r mutateFunction}
group_mutation <- function(object, parent){
  mutate <- parent <- as.vector(object@population[parent,])
  
  groups <- matrix(parent, ncol = nbStudents, byrow = TRUE)
  groups <- groups[rowSums(groups) != 0, ]
  
  selectedGroupIds <- sample(1:nrow(groups), 2, replace = FALSE)
  
  # select students to exchange
  group1 <- selectedGroupIds[1]
  student1 <- sample(which(groups[group1,] == 1), 1)
  group2 <- selectedGroupIds[2]
  student2 <- sample(which(groups[group2,] == 1), 1)
  
  # remove student from their groups
  mutate[nbStudents * (group1-1) + student1] = 0
  mutate[nbStudents * (group2-1) + student2] = 0
  
  # add them into the other groups
  mutate[nbStudents * (group1-1) + student2] = 1
  mutate[nbStudents * (group2-1) + student1] = 1
  
  return(mutate)
}
```

```{r test-mutateFunction}
GA=ga(
  type='binary',
  fitness=fitness,
  nBits=nbStudents*nbGroupsMax,
  population = group_population,
  crossover = group_crossover,
  mutation = group_mutation,
  maxiter=50,
  popSize=100,
  seed=seed,
  keepBest=TRUE,
  monitor=FALSE 
)
```

```{r plotGA}
plot(GA, ylim=c(0, max(students)))
```

```{r bestsol}
GA@fitnessValue

matrix(GA@solution, ncol = nbStudents, byrow = TRUE)
```

#### TEST VARIATION

```{r test-genoud}
library("rgenoud")

func <- function(sol){
  
  # compute info for each group
  counts <- c()
  means <- c()
  for(i in 1:nbGroupsMax){
    if(length(sol[sol == i]) > 0){
      counts[length(counts) + 1] <- length(sol[sol == i])
      studentIds <- which(sol == i)
      means[length(means) + 1] <- mean(students[studentIds,])
    }
  }
  
  # check veto conditions
  if(any(counts < minStudentsByGroup) || any(counts > maxStudentsByGroup))
    return(0)
  
  # return scores - penalty
  return(mean(means) - sd(means))
}

mat <- matrix(
    rep(c(1,nbGroupsMax),nbStudents),
    nrow = nbStudents, 
    ncol = 2,
    byrow = TRUE
  )

genoudGA <- genoud(
    func,
    nvars = nbStudents,
    max = TRUE,
    pop.size = 100,
    max.generations = 50,
    hard.generation.limit = FALSE,
    Domains = mat,
    boundary.enforcement = 2,
    data.type.int = TRUE,
    print.level = 0
  )

genoudGA$value

genoudGA$par
```
