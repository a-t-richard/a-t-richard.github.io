---
title: "Group making using genetic algorithm"
date: "2022-10-14"
output:
  html_document:
    preserve_yaml: true
    variant: gfm
---

## Introduction

Making relevant groups of students, for example to do some practical exercises or in
[problem-based learning](https://teaching.cornell.edu/teaching-resources/engaging-students/problem-based-learning), 
is one common problem of teachers.
Groups must not be too small, or too large, and the mean "level" of each group should be as
homogeneous as possible.
We don't want one group with only students in difficulty and one group with only "good-grades" students.
In addition, students in each group should get along with each others, and all participate to solve the
exercice.

Generally, we just let the students make their own groups with a size limitation, or we just do
random groups. Obviously, it's quite sub-optimal.

A possible way should be to use a metric (grades, IQ, et.) to evaluate students and make groups
according to this metric.
To illustrate this post, I decided to use the
["Reading the Mind in the Eyes" Test (RMET)](https://link.springer.com/referenceworkentry/10.1007/978-3-319-28099-8_549-1).
This test aims evaluate the "emotional"/"social" intelligence of the subject.
According to [Riedl *et al.* (2021)](https://www.pnas.org/doi/full/10.1073/pnas.2005737118),
an high social perceptiveness of group members is quite corelated to high collective intelligence.
So, why not using RMET as a base to construct groups of students?

Let's first generate some random RMET scores to represent our students.
In my case, I'm teaching to 18-25 years old students at university.
According to [](https://www.frontiersin.org/articles/10.3389/fnagi.2020.607107/full),
the mean RMET's score for this age range is 26 (with a standard deviation of 3.2).

```{r students}
nbStudents <- 20
seed <- 42

set.seed(seed)
rmet <- round(rnorm(nbStudents, mean=26, sd=3.2))
students <- data.frame(rmet)
students
```

Now, what we want to make groups with:

* between 3 and 6 students per group
  (even if groups of 4 and 5 students are prefered)
* a RMET mean score by group the highest possible
* a global RMET standard deviation between groups the
  lowest possible (we don't one group with a poor RMET mean score
  and one other group with a high RMET mean score)

This problem can be seen as a variation of the
[knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).
However, instead of choosing wich item to put in a unique bag,
we want to take all the items and distribute them as homogeneously
as possible into several bags.
Knapsack problem is a
[NP-hard problem](https://en.wikipedia.org/wiki/NP-hardness).
We can then suppose that our variation of this problem is also
NP-hard.

Testing all the possible solutions is then not a option, and
we have to use a 
[metaheuristic algorithm](https://www.sciencedirect.com/science/article/pii/B9780128133149000104).

A genetic algorithm, in our case, could be quite adapted
to explore possible solutions and find the best ones.
It is also the occasion to test, and explain step by step, 
genetic algorithms with a pratical use case.
Beside, [classic knapsack problem](https://towardsdatascience.com/genetic-algorithm-in-r-the-knapsack-problem-3edc5b07d4a7) 
can be solved by using genetic algorithm.

## Naively apply basic genetic algorithm

```{r test}
library(GA)

minStudentsByGroup <- 3
maxStudentsByGroup <- 5

maxGroups <- nbStudents %/% minStudentsByGroup

fitness=function(x)
{
  # each row correspond to a group, each column to a student
  m <- matrix(x, ncol=nbStudents, byrow=TRUE)

  # check veto conditions
  groupByStudent <- colSums(m)
  studentsByGroup <- rowSums(m)
  studentsByGroup <- studentsByGroup[studentsByGroup != 0] # dont care about empty groups
  if(any(groupByStudent != 1) || any(studentsByGroup < min) || any(studentsByGroup > max))
    return(0)

  # compute mean RMET by group
  total <- 0.0
  means <- c()
  for(i in 1:maxGroups){
    studentsInGroup <- m[i, ]
    if(any(studentsInGroup == 1)){
    	rmets <- students[studentsInGroup==1,]
    	means[as.character(i)] <- mean(rmets)
    }
  }

  # compute scores and penalty
  score <- mean(means)
  penalty <- sd(means)
  
  # return score - penalties
  return(score - penalty)
}


#GA=ga(type='binary',fitness=fitness,nBits=nbStudents*maxGroups,maxiter=10,popSize=10, pcrossover=0.1, pmutation = 0.8, seed=seed, keepBest=TRUE)
#summary(GA)
#plot(GA)
```

```{r nbComb}
library(gtools)
library(collections)

nbBase <- 20
min <- 3
max <- 5
nbGroupMax <- nbBase %/% min
nbGroupMin <- nbBase %/% max
diffGroupSize <- c(min:max)

diffGroupSizesCombinations <- dict()
k <- 1
nbcombinations <- 0
for(i in nbGroupMin:nbGroupMax){
  c <- combinations(n=length(diffGroupSize), r=i, v = diffGroupSize, repeats.allowed = TRUE)
  
  for(j in 1:nrow(c)){
    rj <- c[j, ]
    if(sum(rj) == nbBase){
      print(rj)
      diffGroupSizesCombinations$set(as.character(k), rj)
      k = k + 1
      nc <- 1.0
      n <- nbBase
      for(r in rj){
        nc = nc * nrow(combinations(n=n, r=r))
        n = n - r
      }
      print(nc)
      nbcombinations = nbcombinations + nc
    }
  }
}

nbcombinations
```

## Reduce solutions’ scope to only valid possibilities

### Initial population

```{r popFunc}
group_population <- function(ga){
  # init population with empty matrix
  population <- matrix(rep(0, ga@nBits*ga@popSize),ncol=ga@nBits, nrow=ga@popSize)
  
  # generate chromosomes of each individual of the population
  for(i in 1:ga@popSize){
    # choose one possible combination of group size
    k <- sample(1:diffGroupSizesCombinations$size(), 1)
    groupSizes <- diffGroupSizesCombinations$get(as.character(k))
    studentsNotGroupedYet <- 1:nbStudents
    for(j in 1:length(groupSizes)){
      # choose n students from students not grouped yet
      studentIds <- sample(studentsNotGroupedYet, groupSizes[j])
      for(id in studentIds){
        # set student to group j
        population[i, nbStudents * (j-1) + id] = 1
        # remove student from students to group
        studentsNotGroupedYet = studentsNotGroupedYet[studentsNotGroupedYet != id]
      }
    }
  }
  
  return(population)
}
```

```{r test-popFunc}
GA=ga(
  type='binary',
  fitness=fitness,
  nBits=nbStudents*maxGroups,
  population = group_population,
  maxiter=10,
  popSize=100,
  seed=seed,
  keepBest=TRUE)
```

### Cross-over best solutions

```{r coFunc}

group_crossover = function(object, parents){
  parentsFitness <- object@fitness[parents]
  parents <- object@population[parents,,drop = FALSE]
  n <- ncol(parents)
  
  children <- matrix(rep(0, 2*n), nrow = 2, ncol = n)
  childrenFitness <- rep(NA, 2)
  
  for(i in 1:nrow(parents)){
    # Select groups in parent 1
    parent1 <- parents[i,]
    groups <- matrix(parent1, ncol = nbStudents, byrow = TRUE)
    nbStudentsByGroup <- rowSums(groups)
    nbStudentsByGroup <- nbStudentsByGroup[nbStudentsByGroup != 0]
    nbGroupKept <- (length(nbStudentsByGroup) - 1) %/% 2
    groupKeptIds <- sample(1:length(nbStudentsByGroup), nbGroupKept, replace = FALSE)
    groupIdsLeft <- 1:length(nbStudentsByGroup)
    studentIdsLeft <-1:nbStudents
    for(groupKeptId in groupKeptIds){
      groupKept <- groups[groupKeptId,]
      studentIds <- which(groupKept == 1)
      for(studentId in studentIds){
        children[i, nbStudents * (groupKeptId-1) + studentId] = 1
        studentIdsLeft = studentIdsLeft[studentIdsLeft != studentId]
      }
      groupIdsLeft = groupIdsLeft[groupIdsLeft != groupKeptId]
    }
    
    # Select groups in parent 2 to keep their internal structures
    parent2 <- if(i==1) parents[2,] else parents[1,]
    groupsInParent2 <- matrix(parent2, ncol = nbStudents, byrow = TRUE)
    studentsByGroupsInParent2 <- rowSums(groupsInParent2)
    nbGroupsInParent2 <- length(studentsByGroupsInParent2[studentsByGroupsInParent2 != 0])
    
    while(length(groupIdsLeft) > 1){
      groupId <- sample(groupIdsLeft, 1)
      groupSize <- nbStudentsByGroup[groupId]
      while(groupSize > 0){
        groupIdInParent2 <- sample(1:nbGroupsInParent2, 1)
        studentIds <- which(groupsInParent2[groupIdInParent2, ] == 1)
        studentSelectedIds <- intersect(studentIds, studentIdsLeft)
        if(length(studentSelectedIds) > groupSize)
          studentSelectedIds <- sample(studentSelectedIds, groupSize, replace = FALSE)
        
        for(studentId in studentSelectedIds){
          children[i, nbStudents * (groupId-1) + studentId] = 1
          studentIdsLeft = studentIdsLeft[studentIdsLeft != studentId]
        }
        groupSize = groupSize - length(studentSelectedIds)
      }
      groupIdsLeft = groupIdsLeft[groupIdsLeft != groupId]
    }
    
    # Fill last group left with students left
    for(studentId in studentIdsLeft){
      groupId <- groupIdsLeft[1]
      children[i, nbStudents * (groupId-1) + studentId] = 1
    }
  }
  
  return(list(children=children, fitness=childrenFitness))
}

```

```{r test-coFunc}
GA=ga(
  type='binary',
  fitness=fitness,
  nBits=nbStudents*maxGroups,
  population = group_population,
  crossover = group_crossover,
  pmutation=0.0,
  maxiter=10,
  popSize=10,
  seed=seed,
  keepBest=TRUE)
```

## TEST VARIATION

```{r testpermutation}
library("rgenoud")

func <- function(sol){
  
  counts <- c()
  for(i in 1:6){
    if(length(sol[sol == i]) > 0)
      counts[as.character(i)] <- length(sol[sol == i])
  }
    
  
  if(any(counts < 3) || any(counts > 5))
    return(0)
  
  return(100)
  
}

mat <- matrix(rep(c(1,6),20),20,2,byrow = TRUE)

GA <- genoud(
    func,
    nvars = 20,
    max = FALSE,
    pop.size = 1000,
    max.generations = 100,
    Domains = mat,
    boundary.enforcement = 2,
    data.type.int = TRUE
  )

GA$value

GA$par
```